<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Execution on misthi0s.dev</title>
    <link>https://misthi0s.github.io/categories/execution/</link>
    <description>Recent content in Execution on misthi0s.dev</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Dec 2024 12:42:00 +0000</lastBuildDate>
    <atom:link href="https://misthi0s.github.io/categories/execution/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Alternate Execution Methods - Encoding Payloads and Executing In-Memory via PowerShell</title>
      <link>https://misthi0s.github.io/posts/2024-12-01-alternate-execution-methods-encoding-in-memory-powershell/</link>
      <pubDate>Sun, 01 Dec 2024 12:42:00 +0000</pubDate>
      <guid>https://misthi0s.github.io/posts/2024-12-01-alternate-execution-methods-encoding-in-memory-powershell/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll go over a fun little project I&amp;rsquo;ve been working on; encoding an executable and using a PowerShell script to decode it and execute it in-memory. This is a common technique employed by malware to try to evade security tools on the infected system. By not writing a malicious executable to disk, there&amp;rsquo;s less of a chance that any sort of endpoint security tool will detect and quarantine it before it can be executed. While this example will be rather simplistic in nature, it will hopefully outline how easy such a technique can be performed and provide some insight into one of many ways that threat actors will try to get their payload executed on their target.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
